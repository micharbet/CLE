#
## ** cle-power: powerprompt-like **
#
#* version: 2021-12-27
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: GNU GPL v2
#* Copyright (C) 2021 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# ALL STILL VERY EXPERIMENTAL
# TODO: doesn't work in TMUX and GNU Screen
#

_clepowershades () {
	local RGB OLDSTTY R RR G GG B BB Y X I

	# get RGB values from background
	# https://superuser.com/questions/157563/programmatic-access-to-current-xterm-background-color
	local OLDSTTY=$(stty -g)
	stty raw -echo min 0
	echo -en "\e]11;?\e\\" >/dev/tty
	read -t 0.1 -r -d '\' </dev/tty
	stty $OLDSTTY
	# _clevdump REPLY
	RGB=`sed 's;.\+rgb:\(..\)../\(..\)../\(..\)...\+;\1 \2 \3;' <<<$REPLY`
	read R G B <<<$RGB

	# calculate luminance
	Y=$((0x$Rx299+0x$G*587+0x$B*114))
	Y=$(($Y/1000))

	#echo RGB: $R $G $B
	#echo Y: $Y

	# Identify dark/light background and adjust shade cofficients
	# Value of 89 is just in the middle between 0 and 178 which is maximum
	# luminanace calculated with above formula when RGB=#ffffff. I do not know
	# if this is exactly the middle luminance from human perception but in terminal
	# world, the background is either dark or light. Anything close to middle
	# would be hard to use
	#
	if [ $Y -lt 89 ]; then
		# dark background, shade towards light tones
		X=(75 90 105 120 200)
	else
		# light background, shade to darker
		X=(120 105 95 90 60)
	fi

	# ensure decent shades even on black background
	if [ $Y -lt 5 ]; then
		R=7
		G=7
		B=7
	fi

	# calculate power-shades
	# from $R $G $B, through variables $RR $GG $BB
	# create $_R0 .. $_R4
	for I in 0 1 2 3 4; do
		RR=$((0x$R*${X[I]}/100)); [ $RR -gt 255 ] && RR=255
		GG=$((0x$G*${X[I]}/100)); [ $GG -gt 255 ] && GG=255
		BB=$((0x$B*${X[I]}/100)); [ $BB -gt 255 ] && BB=255
		_P[$I]="$RR;$GG;$BB"
	#	echo _P $I : ${_P[$I]}
	done

	# RGB intros
	_PB=$'\e[48;2;'	# background
	_PF=$'\e[38;2;'	# foreground

	_Cn=			# color reset before prompt colors would destroy powerline
}

_clepower () {
	# Cut and remmeber starting newline
	NL0=
	if [[ $CLE_P0 =~ ^\\n ]]; then
		NL0='\n'
	fi

	# Power-enhance PS1
	# TODO: remove initial and trailing spaces from CLE_Px, powerline adds own
	[ "$CLE_PT" ] && PS1="\\[\${_CT}$(_clesc $CLE_PT)\${_Ct}\\]" || PS1='';
	PS1=$PS1"\\[\${_PB}\${_P[0]}m\\] ^C0$CLE_P0 ^CN"
	PS1=$PS1"\\[\${_PF}\${_P[0]}m\${_PB}\${_P[1]}m\\] ^C1$CLE_P1 ^CN"
	PS1=$PS1"\\[\${_PF}\${_P[1]}m\${_PB}\${_P[2]}m\\] ^C2$CLE_P2 ^CN"
	PS1=$PS1"\\[\${_PF}\${_P[2]}m\${_PB}\${_P[3]}m\\] ^C3$CLE_P3 ^CN"
	PS1=$PS1"\\[\${_PF}\${_P[3]}m\${_PB}\${_P[4]}m\\]^CW^CN\\[\${_PF}\${_P[4]}m\\]^CN^C4 "

	# TODO: create function _clepower similar to _clesc to simply add backgrounds an delimiters

	# replace newlines; remove \$
	PS1=$(sed -e 's/\\n//g' -e 's/\\\$//' <<<$PS1)

	# or leave them ?
	#PS1=$(sed -e 's/\\n/ ^Cn^Cp^CN\n^Cn/g' -e 's/\\\$//' <<<$PS1)
	#PS1=$(sed -e 's/\\n/ ^CN\n/g' -e 's/\\\$//' <<<$PS1)

	#_clevdump PS1
	PS1=$(_clesc "$NL0$PS1") 
	#_clevdump PS1
}

_clepowershades
_clepower

