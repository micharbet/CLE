#
## ** cle-power: powerprompt-like **
#
#* version: 2022-01-05
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: MIT
#* Copyright (C) 2021-2024 by Michael Arbet 

# ALL STILL VERY EXPERIMENTAL
# TODO: doesn't work in TMUX and GNU Screen

# get RGB values from background
# https://superuser.com/questions/157563/programmatic-access-to-current-xterm-background-color
_clepowerbg () {
	local OLDSTTY=$(stty -g)
	stty raw -echo min 0
	echo -en "\e]11;?\e\\" >/dev/tty
	read -t 0.1 -r -d '\' </dev/tty
	stty $OLDSTTY
	# _clevdump REPLY
	sed 's;.\+rgb:\(..\)../\(..\)../\(..\)...\+;\1 \2 \3;' <<<$REPLY
}

# calculate power shades based on backgroung RGB values
_clepowershades () {
	local LUM I X R RR G GG B BB
	
	read R G B <<<$(_clepowerbg)
	# calculate luminance
	LUM=$((0x$Rx299+0x$G*587+0x$B*114))
	LUM=$(($LUM/1000))

	# Identify dark/light background and adjust shade cofficients
	# Value of 89 is just in the middle between 0 and 178 which is maximum
	# luminanace calculated with above formula when RGB=#ffffff. I do not know
	# if this is exactly the middle luminance from human perception but in terminal
	# world, the background is either dark or light. Anything close to middle
	# would be hard to use
	# Values in X array are in percent
	#
	if [ $LUM -lt 89 ]; then
		# dark background, shade towards light tones
		X=(75 90 105 120 200)
	else
		# light background, shade to darker
		X=(120 105 95 90 60)
	fi

	# ensure decent shades even on black background
	if [ $LUM -lt 5 ]; then
		R=7
		G=7
		B=7
	fi

	# calculate power-shades
	# from $R $G $B, through variables $RR $GG $BB
	# create $_R0 .. $_R4
	for I in 0 1 2 3 4; do
		RR=$((0x$R*${X[I]}/100)); [ $RR -gt 255 ] && RR=255
		GG=$((0x$G*${X[I]}/100)); [ $GG -gt 255 ] && GG=255
		BB=$((0x$B*${X[I]}/100)); [ $BB -gt 255 ] && BB=255
		_P[$I]="$RR;$GG;$BB"
	#	echo _P $I : ${_P[$I]}
	done

	# RGB intros
	_PB=$'\e[48;2;'	# background
	_PF=$'\e[38;2;'	# foreground
}

# fuction to add power shades to the prompt string
# For now also removes newlines - TODO: think how to handle them better to allow
# multiline power prompt
#
_clepoweresc () {
	sed \
	-e 's/\\\$//' \
	-e 's/\\n//g' \
	-e 's/\^P34/\\[\${_CN}\${_PF}\${_P[3]}m\${_PB}\${_P[4]}m\\]^CW^CN\\[\${_PF}\${_P[4]}m\\]^CN^C4/' \
	-e 's/\^P\([0-9]\)\([0-9]\)/\\[\${_CN}\${_PF}\${_P[\1]}m\${_PB}\${_P[\2]}m\\]/g' \
	<<<"$*"
}

# Craft the power prompt
_clepower () {
	local PS PX NL0 I

	# color reset before prompt colors would destroy powerline
	_Cn=

	# Cut and remmeber starting newline
	# Can be removed if I find better way to handle multiline power prompt
	NL0=
	if [[ $CLE_P0 =~ ^\\n ]]; then
		NL0='\n'
	fi

	# start with window title
	[ "$CLE_PT" ] && PS="\\[\${_CT}$CLE_PT\${_Ct}\\]^P00" || PS='^P00';

	# Power-enhance original prompt parts
	for I in 0 1 2 3; do
		# get the current prompt part
		PX=CLE_P$I
		PX=${!PX}
		# trim starting and trailing spaces
		PX=${PX%%*( )}
		PX=${PX##*( )}
		PX="^C$I$PX ^P$I$((I+1)) "
		PS=$PS$PX
		#_clevdump PS
	done

	PS=`_clepoweresc "$PS"`
	PS1=`_clesc "$NL0$PS"`
}

_clepowershades
_clepower

