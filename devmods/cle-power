#
## ** cle-power: powerprompt-like **
#
#* version: 2021-11-24
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* license: GNU GPL v2
#* Copyright (C) 2021 by Michael Arbet 
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# ALL STILL VERY EXPERIMENTAL
# and useless in screen

# function to grab RGB values of background
# TODO: doesn't work in TMUX
getbg () {
	local OLDSTTY=$(stty -g)
	stty raw -echo min 0
	echo -en "\e]11;?\e\\" >/dev/tty
	read -t 0.1 -r -d '\' </dev/tty
	stty $OLDSTTY
	#_clevdump REPLY
	R1=`sed 's/^.*\;//;s/[^rgb:0-9a-f/]//g' <<<$REPLY`
	R2=`sed 's;.\+rgb:\(..\)../\(..\)../\(..\)...\+;\1 \2 \3;' <<<$REPLY`
	#_clevdump R1
	#_clevdump R2
	read R G B <<<$R2
}

# get background RGB values and calculate luminance
getbg
#R=20
#G=20
#B=20
echo RGB: $R $G $B
Y=$((0x$Rx299+0x$G*587+0x$B*114))
Y=$(($Y/1000))
echo Y: $Y

# Identify dark/light background and adjust shade cofficients
# Value of 89 is just in the middle between 0 and 178 which is maximum
# luminanace calculated with above formula when RGB=#ffffff. I do not know
# if this is exactly the middle luminance from human perception but in terminal
# world, the background is either dark or light. Anything close to middle
# would be hard to use
#
if [ $Y -lt 89 ]; then
	# dark background, shade towards light tones
	X0=90
	X1=110
	X2=130
	X3=150
	X4=240
else
	# light background, shade to darker
	X0=105
	X1=95
	X2=90
	X3=85
	X4=50
fi

# ensure decent shades even on black background
if [ $Y -lt 5 ]; then
	R=7
	G=7
	B=7
fi

# calculate power-shades
for C in R G B; do
	for I in 0 1 2 3 4; do
		eval "$C$I=\$((0x\$$C*\$X$I/100)); [ \$$C$I -gt 255 ] && $C$I=255"
	done
done

# complete RGB sequences
P0="$R0;$G0;$B0"
P1="$R1;$G1;$B1"
P2="$R2;$G2;$B2"
P3="$R3;$G3;$B3"
P4="$R4;$G4;$B4"

#echo $P0
#echo $P1
#echo $P2
#echo $P3
#echo $P4

_Cn=
_Ce=$_CR	#error highligt without reverse
_Cp=$'\E[37;40m' # prompt ending

# Cut and remmeber starting newline
NL0=
if [[ $CLE_P0 =~ ^\\n ]]; then
	#CLE_P0=${CLE_P0/\\n/}
	NL0='\n'
fi

# Power-enhance PS1
PS1=$"\\[\e[38;2;\${P0}m\\]\\[\e[48;2;\${P0}m\e[30m\\]^C0$CLE_P0^CN"
PS1=$PS1$"\\[\e[38;2;\${P0}m\e[48;2;\${P1}m\\] ^C1$CLE_P1^CN"
PS1=$PS1$"\\[\e[38;2;\${P1}m\e[48;2;\${P2}m\\] ^C2$CLE_P2^CN"
PS1=$PS1$"\\[\e[38;2;\${P2}m\e[48;2;\${P3}m\\] ^C3$CLE_P3^CN"
PS1=$PS1$"\\[\e[38;2;\${P3}m\e[48;2;\${P4}m\\]^CW^CN\\[\e[38;2;\${P4}m\\]^CN^C4 "

# replace newlines; remove \$
PS1=$(sed -e 's/\\n//g' -e 's/\\\$//' <<<$PS1)
# different '^E' processing (doesn't work!)
#PS1=$(sed "s/\^E/\\\\[\$_CE\\\\]\\\\[\${_CV}\\\\]\$_EC$_CN\\\\[$_Cn\$_C0\\\\]/g" <<<$PS1)

# or leave them ?
#PS1=$(sed -e 's/\\n/ ^Cn^Cp^CN\n^Cn/g' -e 's/\\\$//' <<<$PS1)
#PS1=$(sed -e 's/\\n/ ^CN\n/g' -e 's/\\\$//' <<<$PS1)

#_clevdump PS1
PS1=$(_clesc "$NL0$PS1") 
#PS1=$(_clesc "$PS1") 
#_clevdump PS1


