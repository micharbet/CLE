#!/usr/bin/env bash
##
## ** CLE : Command Live Environment **
##
#* author:  Michael Arbet (marbet@redhat.com)
#* home:    https://github.com/micharbet/CLE
#* version: 2025-11-11 (Aquarius)
#* license: MIT
#* Copyright (C) 2016-2025 by Michael Arbet

# CLE provides:
# -improved look&feel: responsive colorful prompt, highlighted exit code
# -persistent alias store - command 'aa'
# -rich history - commands 'h' and 'hh'
# -seamless remote CLE session, with no installation - use 'lssh' instead 'ssh'
# -local live session - lsu/lsudo (su/sudo wrappers)
# -setup from command line, eg. 'cle color RGB'
# -documentation available with 'cle help' and 'cle doc'
#
# Quick setup:
# 1. Download and execute this file within your shell session
# 2. Integrate into your profile:
#	$ . clerc
#	$ cle deploy
# 3. Enjoy!
# Warning: magic inside!


# Check if the shell is interactive and CLE not yet started
[ -t 0 -a -z "$CLE_EXE" ] || return

# Startup sequence
export CLE_RC
if [[ ${BASH_SOURCE[0]} == "$0" ]]; then
    export CLE_PROF=1
    exec bash --rcfile "${BASH_SOURCE[0]}"
fi


CLE_RC=${BASH_SOURCE[0]}

# Use alias built-ins for startup
unset -f alias unalias 2>/dev/null
unalias aa h hh .. ... 2>/dev/null

# execute script and log its filename into CLE_EXE
_clexe() {
	[ -f "$1" ] || return 1
	[[ $CLE_EXE =~ :$1[:$] ]] && return
	CLE_EXE=$CLE_EXE:$1
	source $1
}
CLE_EXE=$CLE_RC

# Run profile files
if [ -n "$CLE_PROF" ]; then
	_clexe /etc/profile
	_clexe $HOME/.bashrc
	unset CLE_PROF
fi

# Check first run
if [[ $CLE_RC =~ clerc ]]; then
	CLE_DR=$HOME/.cle-$USER
	mkdir -m 755 -p $CLE_DR
	CLE_1=$CLE_DR/rc1
	cp $CLE_RC $CLE_1
	chmod 755 $CLE_1
	CLE_RC=$CLE_1
fi

CLE_DR=$(cd ${CLE_RC%/*};pwd;)
CLE_RC=$CLE_DR/${CLE_RC##*/}

# FQDN hack
CLE_FHN=$HOSTNAME
_N=`hostname 2>/dev/null`
[ ${#CLE_FHN} -lt ${#_N} ] && CLE_FHN=$_N
CLE_SHN=${CLE_FHN%.*.*}

_N=${SSH_CONNECTION% *}
CLE_IP=${_N##* }

# where in the deep space CLE grows
CLE_VER=`sed -n 's/^#\* version: //p' $CLE_RC`
_N=${CLE_VER%)*}
CLE_REL=${_N#* (}
CLE_REL=dev              # REMOVE THIS ON RELEASE!!!!!
CLE_SRC=https://raw.githubusercontent.com/micharbet/CLE/$CLE_REL

# find writable folder
_T=/var/tmp/$USER
_H=$HOME
[ -w $_H ] || _H=$_T
[ -r $HOME ] || HOME=$_H
[ $PWD = $_T ] && cd
_N=.${CLE_RC#*.}
CLE_D=$_H/${_N%/*}
mkdir -m 755 -p $CLE_D

# config, tweak, etc...
CLE_CF=$CLE_D/cf
[ -f $CLE_CF-$CLE_FHN ] && CLE_CF=$CLE_D/cf-$CLE_FHN
CLE_AL=$CLE_D/al
CLE_HIST=$_H/.clehistory
CLE_WS=${CLE_RC#$CLE_DR/rc}
CLE_TW=$CLE_DR/tw$CLE_WS
CLE_ENV=$CLE_DR/env$CLE_WS

CLE_HIGNORE="^cd\ |^cd$|^-$|^\.\.$|^\.\.\.$|^aa$|^lscreen|^h$|^hh$|^hh\ |^cle\ (p[123abpt]|color)"

# who I am
_N=${CLE_RC#*cle-}
_N=${_N%/rc*}
export CLE_USER=${CLE_USER:-${_N:-$USER}}

# Internal functions

_clebnr() {
	cat <<EOT

$_CY   ___| |     ____| $_CN     Command Live Environment
$_CG  |     |     __|   $_CN brings life to the command line!
$_Cg  |     |     |
$_Cg$_CD \____|_____|_____|    $_CN Read$_CI cle help$_CN and$_CI cle doc$_CN
EOT
}

# boldprint
_clebold() { printf "$_CL$*$_CN\n"; }

# simple question
_cleask() (
	PR="$_CL$* (y/N) $_CN"
	read -n 1 -s -p "$PR"
	echo ${REPLY:=n}
	[ "$REPLY" = "y" ]
)

# Create color table
_cletable() {
	_C_=$TERM
	_Cn=$'\E[0m'
	_CN=`tput sgr0`; _CN=${_CN:-$_Cn}
	_CL=`tput bold`; _CL=${_CL:-$'\E[1m'}
	_CU=`tput smul`
	_Cu=`tput rmul`
	_CV=`tput rev`
	_CI=`tput sitm`
	_Ci=`tput ritm`
	_CD=`tput dim`
	_Ck=`tput setaf 0`; _Ck=${_Ck:-$'\E[30m'}
	_Cr=$(tput setaf 1); _Cr=${_Cr:-$'\E[31m'}
	_Cg=$(tput setaf 2); _Cg=${_Cg:-$'\E[32m'}
	_Cy=$(tput setaf 3); _Cy=${_Cy:-$'\E[33m'}
	_Cb=$(tput setaf 4); _Cb=${_Cb:-$'\E[34m'}
	_Cm=$(tput setaf 5); _Cm=${_Cm:-$'\E[35m'}
	_Cc=$(tput setaf 6); _Cc=${_Cc:-$'\E[36m'}
	_Cw=$(tput setaf 7); _Cw=${_Cw:-$'\E[37m'}
	case $(tput colors) in
	8|'')
		_CK=$_Ck$_CL
		_CR=$_Cr$_CL
		_CG=$_Cg$_CL
		_CY=$_Cy$_CL
		_CB=$_Cb$_CL
		_CM=$_Cm$_CL
		_CC=$_Cc$_CL
		_CW=$_Cw$_CL
		;;
	*)
		_CK=$(tput setaf 8)$_CL
		_CR=$(tput setaf 9)$_CL
		_CG=$(tput setaf 10)$_CL
		_CY=$(tput setaf 11)$_CL
		_CB=$(tput setaf 12)$_CL
		_CM=$(tput setaf 13)$_CL
		_CC=$(tput setaf 14)$_CL
		_CW=$(tput setaf 15)$_CL
		;;
	esac
	_Ce=$_CR$_CL
} 2>/dev/null

# set prompt colors
_cleclr() {
	local C I CI E
	case "$1" in
	red)    C=RrR ;;
	green)  C=GgG ;;
	yellow) C=YyY ;;
	blue)   C=BbB ;;
	cyan)   C=CcC ;;
	magenta) C=MmM ;;
	grey | gray) C=wNW ;;
	tricolora) C=RBW ;;
	marley) C=RYG ;; # Bob Marley style :-) have a smoke and imagine...
	*)		C=$1 ;;
	esac
	# decode colors and prompt strings
	#[ ${#C} = 3 ] && C=D${C}L || C=${C}L
	C=x${C}L
	for I in {1..4};do
		eval "CI=\$_C${C:$I:1}"
		# check for exsisting color, ignore if 'dim' and 'italic' are empty
		if [[ -z "$CI" && ! ${C:$I:1} =~ [ID] ]]; then
			echo "Wrong color code '${C:$I:1}' in $1" && CI=$_CN
			E=1
		fi
		eval "_C$I=\$CI"
	done
	_C5=$_C4$_CD
	if [ $E ]; then
		printf "Choose a predefined scheme: "
		declare -f _cleclr|sed -n 's/^[ \t]*(*\(\<[a-z |]*\)).*/ \1/p'|tr -d '\n|'
		printf "\nAlternatively create your own 3 or 4 letter combo using rgbcmykw/RGBCMYKW\n"
		printf " e.g.:$_CL cle color rgB\n"
		_cleclr gray
		return 1
	else
		CLE_PC=${C:1:4}
	fi
}

# terminal background manipulations
_clebg() {
	[ "$CLE_BG" ] || return
	_C0=$'\e]11;'$CLE_BG$'\e\\'
}

# CLE prompt escapes
_clesc() (
	sed \
		-e 's/\^i/\${CLE_IP}/g'\
		-e 's/\^h/\${CLE_SHN}/g'\
		-e 's/\^H/\${CLE_FHN}/g'\
		-e 's/\^U/\${CLE_USER}/g'\
		-e 's/\^s/\${_SEC}/g'\
		-e 's/\^t[0-9]*//g'\
		-e 's/\^g/\\[${_GITC}\\]${_GITB}/g'\
		-e 's/\^[?e]/\${_EC}/g'\
		-e 's/\^E/\${_ET}/g'\
		-e 's/\^C\([0-9]\)/\\[${_Cn}${_C\1}\\]/g'\
		-e 's/\^C\(.\)/\\[${_C\1}\\]/g'\
		-e 's/\^v\([[:alnum:]_]*\)/\1=\${\1}/g'\
		-e 's/\^\^/\^/g'\
		<<<"$*"
)

_cle_r() {
	[ "$1" != h ] && return
	printf "\n$_Cr     ,~~---~^^, \n    /@=-. ##_##\\ \n .,(. ##########)\n(@###,. \`\"######@^."
	printf "\n \`@#####\`..#####\`,###)\n$_CW   (@@$_Cr^#############\"\n$_CW"
	printf "    \\@@@\\__,-~-__,\n     \`@@@@@@69@@/\n        *&@@@@&*\n$_CN\n"
}

# craft prompts from defined strings
_cleps() {
	local PT PA PB
	if declare -p CLE_PT &>/dev/null; then
		PT=${CLE_PT}
	else
		[ "$_ST" ] && PT=$_ST || PT=${_PT}
	fi
	PA=${CLE_PA:-$_PA}
	PB=${CLE_PB:-$_PB}
	[ "$PT" ] && PS1="\\[\${_CT}$(_clesc $PT)\${_Ct}\\]" || PS1=''
	PS1=$PS1$(_clesc "^CN^C1${CLE_P1:-$_P1}^CN^C2${CLE_P2:-$_P2}^CN^C3${CLE_P3:-$_P3}^CN^C4")
	PS2=`_clesc "^C3>>> ^CN^C4"`
	[ "$PB" ] && _PSB=$(_clesc "^CN^C5$PB")
	[ "$PA" ] && {
		_PSA=`_clesc "^CN^CE$PA"`
		[ $BASH_VERSINFO -lt 5 ] && _PSA=$(sed -e 's/\\.//g' -e 's/"/\\"/g' <<<"$_PSA")
		PT=`sed -n 's/.*\^t\([0-9]*\).*/\1/p' <<<$PA`
        CLE_PAHOLD=${CLE_PAHOLD:-0}
	}
}

# default prompt strings and colors
_cledefp() {
	_P1='\u '
	_P2='^h '
	_P3='\w \$ '
	_PB=
	_PA='-<(^e)>-'
	_PT='\u@^H'
	case "$USER@$CLE_WS" in
	root@) _DC=red ;;
	*@) _DC=marley ;;
	root@*) _DC=RbB ;;
	*@*) _DC=blue ;;
	esac
}

# save configuration
_clesave() (
	echo "# $CLE_VER"
	vdump CLE_P.
) >$CLE_CF

# prompt callback functions
_PST='${PIPESTATUS[@]}'
[ "$BASH_VERSINFO" = 3 ] && _PST='$?'
_TIM=
CLE_HTF='%F %T'
HISTTIMEFORMAT=${HISTTIMEFORMAT:-$CLE_HTF }
history -cr $HISTFILE

_cle_preexec() {
    trap - DEBUG
	local _HR
	_HR=$(HISTTIMEFORMAT=";$CLE_HTF;" history 1)
	_HR=${_HR#*;}
	_DT=${_HR/;*/}
	_CMD=${_HR/$_DT;/}

    [[ "$BASH_COMMAND" =~ ^_ ]] && return
    _TIM=${_TIM:-$SECONDS}

    if ! [[ $_CMD =~ $CLE_HIGNORE ]]; then
        [ "$_ST" ] && _SC=${_CMD:0:15} || _SC=${_CMD:0:99}
        { [ -z "${CLE_PT+x}" ] || [ -n "$CLE_PT" ]; } && printf "$_CT%s$_Ct" "$_SC"
    fi
    [ "$_PSB" ] && \
        { [ $BASH_VERSINFO -ge 5 ] && echo "${_PSB@P}" || eval "echo \"$_PSB\""; } >/dev/tty
    echo -n $_CN >/dev/tty
}

_cle_postexec() {
	eval "_EC=$_PST"
	_EC=${_EC// /-}
	[ $CLE_BG ] && printf '\e]11;'$CLE_BG'\e\\' >/dev/tty

	if [[ "$_TIM" || "$_CMD" =~ ^\# ]]; then
		if [[ $_EC =~ [1-9] ]]; then
            _CE=$_Ce
            _ET="Err=$_EC"
        else
            _CE=$_C5
            _ET=OK
        fi
		# _CA=${_CE:-$_C5}
		_SEC=$((SECONDS-_TIM))
		[[ $PS1 =~ _GIT ]] && _clegit
		history -a
		[ "$_PSA" ] && [ $_SEC -ge "$CLE_PAHOLD" -o "$_EC" != 0 ] && \
			 { [ $BASH_VERSINFO -ge 5 ] && echo "${_PSA@P}" || eval "echo \"$_PSA\""; } >/dev/tty
		_clerh "$_DT" $_SEC "$_EC" "$PWD" "$_CMD"
	else
		_CE=
		_EC=0
	fi
    _TIM=
	trap _cle_preexec DEBUG
}

# rich history record
_CPR=
_clerh() {
	local DT RC REX ID V VD W
	case $# in
	3)	DT=$(date "+$CLE_HTF");SC='';;
	4)	DT=$(date "+$CLE_HTF");SC=$1;shift;;
	5)	DT=$1;SC=$2;shift 2;;
	esac
	[[ $3 =~ $CLE_HIGNORE ]] && return
	[ "$3" = "$_CPR" ] && return
	_CPR=$3
	W=${2/$HOME/\~}
	ID="$DT;$CLE_USER-$$"
	REX='^\$[A-Za-z0-9_]+'
	case "$3" in
	echo*)
		echo -E "$ID;$SC;$1;$W;$3"
		for V in $3; do
			if [[ $V =~ $REX ]]; then
				V=${V/\$/}
				VD=`vdump $V`
				echo -E "$ID;;$;;${VD:-unset $V}"
			fi
		done
		;;
	xx) # directory bookmark
		echo -E "$ID;;*;$PWD;";;
	\#*)
		echo -E "$ID;;#;$W;$3";;
	*)
		echo -E "$ID;$SC;$1;$W;$3";;
	esac
} >>$CLE_HIST

# Remove alias 'which' if there is version not supporting extended options
{ alias|command which -i which||unalias which; } >/dev/null 2>&1

## ** cd command enhancements **
## `.. ...`     - up one or two levels
## `-`  (dash)  - cd to recent dir
-() { cd - >/dev/null;vdump OLDPWD;}
..() { cd ..; }
...() { cd ../..; }
## `xx` & `cx`   - bookmark $PWD & use later
xx() { _XX=$PWD;echo path bookmark: $_XX;}
cx() { cd $_XX; }

##
## ** Alias management **
aa() {
	local ATMP=$CLE_AL.tmp
	case "$1" in
	"") ## `aa`         - show aliases
		builtin alias|sed "s/^alias \([^=]*\)=\(.*\)/$_CL\1$_CN	\2/" ;;
	-s) ## `aa -s`      - save aliases
		if [ $CLE_WS ]; then
			grep "^alias " $CLE_ENV >$ATMP
			builtin alias | diff - $ATMP | sed -n 's/^< \(.*\)/\1/p' >$CLE_AL
			rm -f $ATMP
		else
			builtin alias >$CLE_AL
		fi;;
	-e) ## `aa -e`      - edit aliases
		builtin alias >$ATMP
		vi $ATMP
		builtin unalias -a
		. $ATMP
		rm -f $ATMP;;
	*=*) ## `aa a='b'`   - create new alias and save
		builtin alias "$*"
		aa -s;;
	*) builtin alias "$*";;
	esac
}

##
## ** Rich history tools **
## `h`               - regular 'history' wrapper
h() (
	(HISTTIMEFORMAT=";$CLE_HTF;" history "$@") | (
		IFS=';'
		while read -r N DT C; do
			echo -E "$_CB$N$_Cb $DT $_CN$_CL$C$_CN"
		done
	)
)

## `hh [opt] [srch]` - query the rich history
_RHI=1
_RHLEN=0
hh() {
	local O S N D C OPTIND MOD OUT
	while getopts "a:mtwsnrcflbex0123456789" O; do
		case $O in
		t) ## `hh -t`           - commands from current session/terminal
			S=$S"&& \$2==\"$CLE_USER-$$\"";;
		w) ## `hh -w`           - search for commands issued from current working directory`
			N=${PWD/$HOME/\~}
			S=$S"&& \$5==\"$N\"";;
		m) ## `hh -m`           - my commands, exclude other users
			S=$S"&& \$2~/^$CLE_USER-/";;
		[0-9])                                ## `hh -0..9`        - 0: today's commands, 1: yesterday's, etc.
			C="\$1~/$(date -d -${O}days '+%F')/"
			[ "$D" ] && D="$D || $C" || D="$C";;
		a)  ## `hh -a string`    - search for any string in history
			S=$S"&&/${OPTARG//\//\\/}/";;
		s) ## `hh -s`           - select successful commands only
			S=$S"&& \$4==0";;
		n) ## `hh -n`           - narrow output, hide time and session id
			MOD=n;;
		r) ## `hh -r`           - show only real commands
			MOD=r;;
		c) ## `hh -c`           - show only command column - good for copypaste
			MOD=c;;
		f) ## `hh -f`           - show working folder history
			MOD=f;;
		b) ## `hh -b`           - show unique commands in buffer
			OUT='>/dev/null';;
		l) ## `hh -l`           - display using 'less'
			OUT='|less -r +G';;
		e) ## `hh -e`           - edit the rich history file
			vi + $CLE_HIST
			return;;
		x) ## `hh -x`           - remove the most recent history record
			# TODO: maybe... number of lines to remove ev. string? Or add enhanced functionality to a module?
			sed -i '$ d' $CLE_HIST
			history -d -2
			return;;
		*)
			cle help hh
			return;;
		esac
	done
    S=$S"${D:+&& ( $D )}"

	_RHARG="$*"
	shift $((OPTIND-1))

	N=+1
	if [ "$*" ]; then
		[[ $* =~ ^[0-9]+$ ]] && N=$* || {
			C=${*//\//\\/}
			C=${C// /[[:space:]]+}
			[[ $C =~ ^\^ ]] && C=${C/^/} || C=".*$C"
			S=$S"&& /^.+;.+;.*;[0-9 ]+;.*;$C/"
		}
	else
		[ "$S" ] || N=100
	fi

	local AWK='
	BEGIN {
		FS=";"
		CN="'$_CN'"
		CL="'$_CL'"
		CD="'$_CD'"
		CG="'$_CG'"
		CR="'$_CR'"
		Cy="'$_Cy'"
		Cb="'$_Cb'"
		CB="'$_CB'"
	}
	//'$S' {
		CMD=substr($0,index($0,$6))
		CST=CR; CFL=CN; CCM=CL
        if($4==0) { CST=CG }
		if($4=="#" || $4=="$") { CST=Cy; CFL=Cy; CCM=Cy }
		if($4=="*") { CST=Cy; CFL=Cy; CCM=Cy; CMD="cd "$5 }
		if($4=="@") { CST=Cb; CFL=Cb; CCM=Cb }
		if($3!="") { ET=$3 "\"" } else { ET="" }
		if(MOD~"n") {
			FORM=CST "%-9s" CFL " %-25s:" CCM " %s\n" CN
			printf FORM,$4,$5,CMD
		}
		else if(MOD~"r" && $4!~/[0-9]/) next
		else if(MOD~"c") print CMD
		else if(MOD~"f") CMD=$5
		else {
			FORM=CB CD "%s" CN Cb CD" %-13s" CN CD " %6s" CN CST " %-5s" CFL " %-13s:" CCM " %s\n" CN
			printf FORM,$1,$2,ET,$4,$5,CMD
		}
		if( $4~/^[0-9 *]+$/ ) CMDS[I++]=CMD
	}
	END {
		UNIQ="\n"
		while(I-- && N<100 ) {
			C=CMDS[I] "\n"
			if( ! index(UNIQ,"\n" C) ) { UNIQ=UNIQ C; N++ }
		}
		print UNIQ >REVB
	}'

	local REVB=$(mktemp clerh.XXXXXX)
	eval tail -n $N $CLE_HIST \| awk -v MOD='$MOD' -v REVB=$REVB '"$AWK"' $OUT

	_RHBUF=()
	_RHLEN=0
	_RHI=0
	while read -r S; do
		[ -n "$S" ] && _RHBUF[$((++_RHLEN))]=$S
	done <$REVB
	rm -f $REVB
	[ "$OUT" = '>/dev/null' -o "$MOD" = f ] && _clerhbuf
	[ $_RHLEN != 0 ]
}

# rich history up/down shortcut routines
_clerhdown() {
	[[ $READLINE_LINE =~ ^[0-9]+$ ]] && _RHI=$READLINE_LINE || ((_RHI--))
	[ $_RHI -lt 0 ] && _RHI=0
	READLINE_LINE=${_RHBUF[$_RHI]}
	READLINE_POINT=${#READLINE_LINE}
}

_clerhup() {
	[[ $READLINE_LINE =~ ^[0-9]+$ ]] && _RHI=$READLINE_LINE || ((_RHI++))
	[ $_RHI -gt $_RHLEN ] && _RHI=$_RHLEN
	READLINE_LINE=${_RHBUF[$_RHI]}
	READLINE_POINT=${#READLINE_LINE}
}

_clerhbuf() {
	local A N=$_RHLEN
	while [ $N -ge 1 ]; do
		[ $N -eq $_RHI ] && A='*' || A=' '
		printf "$_CN$_CB$A%6d: $_CN$_C4%s\n" $N "${_RHBUF[$N]}"
		((N--))
	done
	echo "$_CN$_CD $_RHLEN records ${_RHARG:+'hh $_RHARG'}"
}

bind -x '"\ek": "_clerhup"'
bind -x '"\ej": "_clerhdown"'
bind -x '"\eh": "hh -b $READLINE_LINE"'
bind -x '"\el": "_clerhbuf"'

if which git >/dev/null 2>&1; then
	_clegit() {
		# go down the folder tree and look for .git
		local D=$PWD
		_GITC=
		_GITB=
		while [ "$D" != '' ]; do
			if [ -d $D/.git -o -f $D/.git ]; then
				git diff-index --quiet HEAD -- || _GITC=$_Cr
				printf -v _GITB $'\ue0a0'%s "$(git symbolic-ref --short HEAD || git rev-parse --short HEAD)"
			fi
			D=${D%/*}
		done
	}
else
	_clegit() { return; }
fi

_clemdf() {
	sed -e "s/^###\(.*\)/$_CL\1$_CN/" \
		-e "s/^##\( *\)\(.*\)/\1$_CU$_CL\2$_CN/" \
		-e "s/^#\( *\)\(.*\)/\1$_CL$_CV \2 $_CN/" \
		-e "s/\*\*\(.*\)\*\*/$_CL\1$_CN/" \
		-e "s/\<_\(.*\)_\>/$_CU\1$_Cu/g" \
		-e "s/\`\`\`/$_CD~~~~~~~~~~~~~~~~~$_CN/" \
		-e "s/\`\([^\`]*\)\`/$_Cg\1$_CN/g"
}

##
## ** Additional commands **
## `mdless [files]`  - parse markdown files or stdin and display through less
mdless() {
	cat $*|_clemdf|less -erFX
}

## `vdump VARNAMES`  - dump variables in reusable way
vdump() (
	declare | awk '/^('$1')=/{print}'
)


##
## ** Live session wrappers **

# Environment packer
CLE_XFUN=
CLE_XFILES=
_clepak() {

	RH=${CLE_DR/\/.*/}
	RD=${CLE_DR/$RH\//}

	pushd . >/dev/null
	if [ $CLE_WS ]; then
		cd $RH
		RC=${CLE_RC/$RH\//}
		XF=`ls $RD/*$CLE_WS`
	else
		for RH in /var/tmp /tmp /home; do
			mkdir -m 0755 -p $RH/$RD 2>/dev/null && break
		done
		cd $RH

		EN=$RD/env-$CLE_FHN
		{
			echo "# evironment $CLE_USER@$CLE_FHN"
			vdump "CLE_P.|^_C." | sed 's/^CLE_P\(.\)/_P\1/'
			vdump "${CLE_XVARS// /|}"
			XAL=${CLE_EXALIAS:-^$}
			grep -v "${XAL//,/=\\|}=" $CLE_AL 2>/dev/null
			for XFUN in $CLE_XFUN; do
				declare -f $XFUN
			done
		} >$EN
		XF="$EN"

		for F in $CLE_XFILES tw rc; do
			RC=$RD/$F-$CLE_FHN
			cp $CLE_DR/$F $RC 2>/dev/null && XF="$XF $RC"
		done
	fi

	[ "$1" = lssh ] && C64=`tar chzf - $XF 2>/dev/null | base64 | tr -d '\n\r '`
	popd >/dev/null
}

_cleprelife() {
	#	[ -n "$CLE_PRELIFE" ] && eval $CLE_PRELIFE
	command -v prelife >/dev/null && prelife "$@"
}

_cleafterlife() {
	_EX=$?
	#tput reset
	[ -f $CLE_D/mod-palette ] && . $CLE_D/mod-palette
	#	[ -n "$CLE_AFTERLIFE" ] && eval $CLE_AFTERLIFE
	command -v afterlife >/dev/null && afterlife "$@"
}

## `lssh [usr@]host`   - access remote system and run CLE
lssh() (
	[ "$1" ] || { cle help lssh; return 1;}
	_cleprelife lssh "$@"
	_clepak lssh
	command ssh -t $* "
		for H in \$HOME /var/tmp/\$USER /tmp/\$USER; do
			mkdir -m 755 -p \$H/${RC%/*} && break
		done
		cd \$H
		[ \"\$OSTYPE\" = darwin ] && D=D || D=d
		echo $C64|base64 -\$D|tar xzmf - 2>/dev/null
		exec bash --rcfile \$H/$RC"
	_cleafterlife lssh "$@"
	return $_EX
)


## `lsudo [user]`      - sudo wrapper; root is the default account
lsudo() (
	_cleprelife lsudo "$@"
	_clepak lsudo
	sudo -i -u ${1:-root} bash --rcfile $RH/$RC
	_cleafterlife lsudo "$@"
	return $_EX
)

## `lsu [user]`        - su wrapper
lsu() (
	_cleprelife lsu "$@"
	_clepak lsu
	S=
	[[ $OSTYPE =~ [Ll]inux ]] && S="-s /bin/bash"
	eval su $S -l ${1:-root} $RH/$RC
	_cleafterlife lsu "$@"
	return $_EX
)


_cledefp

# execute modules, tweaks and aliases
for _T in $CLE_D/mod-*; do
	_clexe $_T
done
_clexe $HOME/.cle-local
_clexe $CLE_TW

[ $CLE_WS ] && _clexe $CLE_ENV

# print MOTD + more
if [ "$CLE_MOTD" ]; then
	[ -f /etc/motd ] && cat /etc/motd
	printf "\n$CLE_MOTD"
	_clebold "\n CLE $CLE_VER\n"
	unset CLE_MOTD
fi

PROMPT_DIRTRIM=3
# Enhnace PATH
for _T in $HOME/bin $HOME/.local/bin; do
	[[ -d $_T && ! $PATH =~ $_T ]] && PATH=$PATH:$_T
done


# OS dependent colorized LS and GREP
case $OSTYPE in
linux*) alias ls='ls --color=auto' ;;
darwin*) export CLICOLOR=1; export LSCOLORS=ExGxBxDxCxEgEdxbxgxcxd;;
FreeBSD*) alias ls='ls -G "$@"';;
*) alias ls='ls -F';; # at least some file type indication
esac

if [ -L `command which grep` ]; then
	unalias grep egrep fgrep xzgrep xzegrep xzfgrep zgrep zegrep zfgrep 2>/dev/null
else
	alias grep='grep --color=auto'
fi

_clexe $CLE_AL

_clexe $CLE_CF

[ "$TERM" != "$_C_" -o -z "$_CN" ] && _cletable # create color table if necessary
_CT=$'\e]0;'; _Ct=$'\007'
case $TERM in
linux) CLE_PT='';;
screen*)
	printf "$_CT screen: $CLE_USER@$CLE_SHN$_Ct"
	_ST='\u'
	_CT=$'\ek'; _Ct=$'\e\\';;
esac

# craft the prompt
_cleps
_cleclr ${CLE_PC:-$_DC}
PROMPT_COMMAND=_cle_postexec

# completions
_clecomp() {
	COMPREPLY=()
    COMPREPLYCMD=
	local C
	local F=`declare -F | sed -n 's/^.*_cle_//p'`
    F=${F//$'\n'/ }
	local M=`ls $CLE_D/cle-* 2>/dev/null | sed 's/^.*cle-//'`
    M=${M//$'\n'/ }
	local A=(color p1 p2 p3 pb pa pt cf mod env update reload doc help $M $F)
	case $3 in
	p1) COMPREPLY="'${CLE_P1:-$_P1}'";;
	p2) COMPREPLY="'${CLE_P2:-$_P2}'";;
	p3) COMPREPLY="'${CLE_P3:-$_P3}'";;
	pb) COMPREPLY="'${CLE_PB:-$_PB}'";;
	pa) COMPREPLY="'${CLE_PA:-$_PA}'";;
	pt) COMPREPLY="'${CLE_PT:-$_PT}'";;
	color) COMPREPLY="'$CLE_PC'";;
	*) 
		if [ "$3" != "$1" ]; then
			[[ " $F " =~ " $3 " ]] && COMPREPLYCMD=`sed -n 's/.*COMPREPLYCMD="\([^"]*\)"/\1/p' <<<$(declare -f _cle_$3)`
			[[ " $M " =~ " $3 " ]] && COMPREPLYCMD=`sed -n 's/.*COMPREPLYCMD="\([^"]*\)"/\1/p' $CLE_D/cle-$3`
			A=(`eval $COMPREPLYCMD`)
		fi
		for C in ${A[@]}; do
			[[ $C =~ ^$2 ]] && COMPREPLY+=($C)
		done ;;
	esac
}
complete -F _clecomp cle

# lssh completion
_N=/usr/share/bash-completion
_clexe $_N/bash_completion
_clexe $_N/completions/ssh
declare -F _known_hosts >/dev/null && complete -F _known_hosts lssh
declare -F _ssh >/dev/null && complete -F _ssh lssh
declare -F _comp_cmd_ssh >/dev/null && complete -F _comp_cmd_ssh lssh

# redefine alias builtins
alias() {
	[ -n "$1" ] && aa "$@" || builtin alias
}

unalias() {
	[ "$1" = -a ] && cp $CLE_AL $CLE_AL.bk
	builtin unalias "$@"
	aa -s
}

# check manual/initial run
[ $CLE_1 ] && cat <<EOT
 It seems you started CLE running file '$CLE_1'.
 Since this is the first run, consider setup in your profile.
 Run following command to hook CLE into your $HOME/.bashrc:
$_CL    cle deploy
EOT

[ -r . ] || cd

# record this startup into rich history
_T=${TMUX:+tmux:$TMUX}
_T=${_T:-${STY:+screen:$STY}}
_T=${_T:-${SSH_CLIENT:+ssh:${SSH_CLIENT%% *}}}
_T=${_T:-$CLE_RC}
_clerh @ ${CLE_WS:-WS} "[$_T]"
_clerh @ $SHELL "$BASH_VERSION, $CLE_VER"

##
## ** CLE command & control **
cle() {
	local C I P S N
	C=$1;shift
	if declare -f _cle_$C >/dev/null; then
		_cle_$C $*
		return $?
	elif [ -f $CLE_D/cle-$C ]; then
		. $CLE_D/cle-$C $*
		return $?
	fi
	case $C in
	color) ## `cle color COLOR`       - set prompt color
		[ $1 ] && _cleclr $1 && _clesave ;;
	p?) ## `cle pX [str]`          - show/define prompt parts
		I=${C:1:1}
		I=${I^}
		if [ $# -eq 0 ]; then
			vdump CLE_P$I
		else
			case "$1" in
			'' | ' ' | off)
				eval "CLE_P$I=''"
				;;
			*)
				S=$*
				eval "CLE_P$I='$*'"
				;;
			esac
		fi
		_cleps
		_clesave
		;;
	cf) ## `cle cf [ed|reset|rev]` - view/edit/reset/revert configuration
		case "$1" in
		ed) vi $CLE_CF && . $CLE_RC;;
		reset) mv -f $CLE_CF $CLE_CF-bk;;
		rev) cp $CLE_CF-bk $CLE_CF;;
		"")
			_clebold "$_CU Default/Inherited configuration:"
			vdump _P. CLE_PC
			if [ -f $CLE_CF ]; then
				_clebold "$_CU$CLE_CF":
				cat $CLE_CF
			fi
			return;;
		*) return;;
		esac
		cle reload
		;;
	deploy) ## `cle deploy`            - hook CLE into user's profile
		P=$HOME/.cle-$USER
		mkdir -p $P
		cp $CLE_RC $P/rc
		CLE_RC=$P/rc
		unset CLE_1
		I='# Command Live Environment'
		S=$HOME/.bashrc
		grep -A1 "$I" $S && _clebold CLE is already hooked in $S && return 1
		_cleask "Do you want to add CLE to $S?" || return
		echo -e "\n$I\n[ -f $CLE_RC ] && . $CLE_RC\n" | tee -a $S
		cle reload;;
	update) ## `cle update [master]`   - install fresh version of CLE
		N=$CLE_D/rc.new
		curl -k ${CLE_SRC/$CLE_REL/${1:-$CLE_REL}}/clerc >$N
		S=`sed -n 's/^#\* version: //p' $N`
		[ "$S" ] || { echo "Download error";return 1;}
		echo current: $CLE_VER
		echo "new:     $S"
		diff $CLE_RC $N >/dev/null && {
			echo No difference
			return 1
		}
		_cleask Do you want to install new version? || return
		cp $CLE_RC $CLE_D/rc.bk
		chmod 755 $N
		mv -f $N $CLE_RC
		cle reload
		N=cle-mod
		[ -f "$CLE_D/$N" ] || return
		echo updating modules
		curl -k $CLE_SRC/modules/$N >$CLE_D/$N && cle mod update
		;;
	reload) ## `cle reload           ` - reload CLE
		unset CLE_EXE
		. $CLE_RC && echo CLE reloaded: $CLE_RC $CLE_VER;;
	mod) ## `cle mod`               - cle module management
		_cleask Activate CLE modules? || return
		N=cle-mod
		P=$CLE_D/$N
		curl -k $CLE_SRC/modules/$N >$P
		grep -q "# .* $N:" $P || { _clebold Module download failed;	rm -f $P; return 1;}
		cle mod "$@";;
	env) ## `cle env`               - inspect variables
		vdump 'CLE.*' | awk -F= "{printf \"$_CL%-12s$_CN%s\n\",\$1,\$2}";;
	help | -h | --help) ## `cle help [fnc]`        - show help
		P=`ls $CLE_D/cle-* 2>/dev/null`
		awk -F# "/\s##\s*.*$@|^##\s*.*$@/ { print \$3 }" ${CLE_EXE//:/ } $P |mdless;;
	doc) ## `cle doc`               - show documentation
		I=`curl -sk $CLE_SRC/doc/index.md`
		[[ $I =~ LICENSE ]] || { echo Unable to get documentation; return 1;}
		PS3="$_CL doc # $_CN"
		select N in $I;do
			[ $N ] && curl -sk $CLE_SRC/doc/$N | mdless
			break
		done;;
	"")
		_clebnr
        echo $_CD
		sed -n 's/^#\*\(.*\)/\1/p' $CLE_RC
		;;
	*)
		echo unimplemented function: cle $C
		echo check cle help
		return 1;;
	esac
}

unset _T _H _C _N _DC

# that's all, folks...
