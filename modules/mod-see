##
## ** mod-see: logfile highlighter **
#
#* version: 2025-01-13
#* author:  Michael Arbet (marbet@redhat.com)
#* license: MIT
#* Copyright (C) 2013-2025 by Michael Arbet 


see () (
	# Note new style of inline help!
	# this can be added to functions and as such help is readable on remote sessions
	# for now there needs to be both
	:
	: '`see [-t sec] [-f file|-l] [-i] [-g regexp]  [RE ...]`'
	## `see [-t sec] [-f file|-l]  [-i] [-g regexp] [RE ...]`
	: ''
	: 'Continuously reads stdin or specified file like tail -f. The `see` hihglights'
	: 'date/time at the begining of each line and also colorizes words or regular'
	: 'expressions provided as the arguments. As an addition timestamps are'
	: 'printed every 60 seconds - configurable value'
	: ''
	# defaults
	TSTAMP=60
	INFILE=""
	HL=""
	GREX=
	IGN=

	while getopts "ht:f:g:il" OPT
	do
		case $OPT in
		f)	: '  -f file     open filename instead of stdin'
			INFILE=$OPTARG
			if [ ! -f $OPTARG ]; then
				echo file $OPTARG not found
				exit 1
			fi
			;;
		l)	: '  -l          read /var/log/messages'
			INFILE=/var/log/messages
			;;
		g)	: '  -g regexp   filter (grep) only lines containing regular expression'
			GREX="/$OPTARG/!d"
			;;
		i)	: '  -i          ignore case'
			IGN=i
			;;
		t)	: '  -t nsec     change timestamps interval, default 60 seconds, use 0 to suppress'
			TSTAMP=$OPTARG
			;;
		*)	# usage
			declare -f see | sed -n "s/^ *: *'\(.*\)';/\1/p" | mdless
			exit 1
			;;
		esac
	done
	shift $((OPTIND-1))

	# date/time, hostname and process downlight
	# in dim only so the content is more apparent
	RE="$GREX;s/^\(.*\s*..:..:..\s*[^:]*:\)/$_CD\1$_CN/"
	# echo "RE='$RE'" # dbg

	# Prepare search/replace expressions to colorize words
	HICOLORS="MGYR" # colors in reverse order
	CI=${#HICOLORS}
	for WORD in "$@"; do
		WORD=${WORD/:/\\:} # escape delimiter in regexp
		[ $CI -gt 0 ] && ((CI--))
		eval "HC=\$_C${HICOLORS:$CI:1}"
		RE="$RE;s:\($WORD\):$HC\1$_CN:g$IGN"
		HL="$HL \"$WORD\""
		# echo "RE='$RE'" # dbg
		# echo "$HC$CI: $WORD$_CN"   # dbg
	done

	# ensure timestamps printed in the background process
	STAMPID=''
	if [ $TSTAMP -gt 0 ]; then
		bash -c "trap 'kill -15 0' EXIT;while true; do date '+$_CB[%Y-%m-%d %T] $_Cb${INFILE:-STDIN}$_CN$_Cb${HL:+$HL}$_CN'; sleep $TSTAMP; done" &
		STAMPID=$!
		trap "date '+$_CB[%Y-%m-%d %T] unsee$_CN'; kill $STAMPID" EXIT
	fi

	# read and highlight
	if [ $INFILE ]; then
		tail -f $INFILE | sed -e "$RE"
	else
		sed -e "$RE"
	fi
)

# export this function to subsequent live sessions
CLE_XFUN="$CLE_XFUN see"

